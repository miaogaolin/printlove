---
title: "深入微服务：2. 研究 Protobuf 时发现一个挺好的算法 — ZigZag"
date: 2021-11-08T17:45:01+08:00
draft: false
categories: ["深入微服务"]
tags: ["ZigZag"]
description: "Protobuf 底层使用的压缩算法，并使用 Go 语言实现"
---


我原本是想研究 Protobuf 原理呢，但在研究过程中发现 Protobuf 在对负数编码时使用到了 ZigZag ****算法，所以才有了本篇。当然你不懂 Protobuf 也完全不影响阅读。

在聊这个算法之前，我们得先补补课，聊聊进制、补码相关的东西。

该篇代码：

[https://github.com/miaogaolin/gofirst/tree/main/zigzag](https://github.com/miaogaolin/gofirst/tree/main/zigzag)

## 进制

这个内容是作为码工挣钱最基础的知识之一。

所谓进制，全称是进位制，就是当某一个位上的信息满了，需要往前进位。比如，某一位上的信息只能容纳十个，超过十个就往前进一位，则是逢十进一的十进制；如果逢二进一，则是二进制；等等。进制之间是可以转换的，比如十进制的 10 等于 二进制的 1010, 也等于十六进制的A，通常写作：

十进制：10 → 二进制：1010 → 十六进制：A

我之前看一本书就讲现在为什么大家通用的是十进制。一个比较有趣的答案说，因为人类只有 10 个手指头，数数的时候，挨个儿数过去刚好十个数，所以十进制自然而然成为默认的进制。如果人类是 12 个手指头，说不定就是十二进制了。

后来计算机的出现，一个数据的有无是最天然的信息承载单元，所以由 0-1 组成的二进制很天然的成为计算机的进制方式。在此基础上，为方便信息的传递，又采用了八进制、十六进制等进制。

好了，因为大家对进制这个东西其实也是比较了解，我就不多扯了，就先说到这儿。

## 三个东西

我们对一个十进制的正整数可以采用相关算法，得到他对应的二进制编码，比如十进制 10 表示为 1010。不过，如果我们要表示负整数，怎么办呢？在计算机的世界里，我们就定义了原码、反码和补码这几个东西。

为了描述简单，我们都假设我们的数字用一个字节（1Byte=8bits）来表示。

### 1. 原码

我们用第一个位表示符号（ 0 为非负数，1 为负数），剩下的位表示值。比如：

- +8 → 原：00001000
- -8 → 原: 10001000

### 2. 反码

我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位，非负数保持不变，负数按位求反。比如：

- +8 → 原：0000 1000 → 反：0000 1000
- -8 → 原：1000 1000 → 反：1111 0111

如果我们用原码或者补码来表示整数的二进制，有什么问题吗？表面上看，似乎挺好的。不过仔细思考就会发现两个问题：

第一，0 居然用两个编码（ +0 和 -0 ）来表示了：

- 原：0000 0000 → 1000 0000
- 反：0000 0000 → 1111 1111

第二，计算机要理解符号位的存在，否则符号位参与运算，就会出现诡异的现象。

**原码**：

1 + (-1)

→ 0000 0001 + 1000 0001

→ 1000 0010

→ -2

明显是不对的！

**反码**：

1 + (-1)

→ 0000 0001 + 1111 111

→ 1111 1111

→ -0

表现的好诡异！

为了解决这些问题，我们在计算机体系中引入了补码。

### 3. 补码

我们用第一位表示符号（ 0 为非负数，1 为负数），剩下的位非负数保持不变，负数按位求反末位加一。

- +8 → 原：0000 1000 → 补：0000 1000
- -8 → 原：1000 1000 → 补：1111 1000

那我们再看看，把符号放进去做运算会有什么样的效果呢？

1 + (-1)

→ 0000 0001 + 1111 1111

→ 0000 0000

→ 0

很明显，通过这样的方式，计算机进行运算的时候，就不用关心符号这个问题，而只需要按照统一的逢二进一的原则进行运算就可以了。

好了，脑补了进制和补码以后，我们就可以进入正题了。

## ZigZag

在绝大多数情况下，我们使用到的整数，往往是比较小的。比如，我们会记录一个用户的 ID、一本书的 ID、一个回复的数量等等。在绝大多数系统里面，他们都是一个小整数，就像 1234、1024、100 等。

而我们在系统之间进行通讯的时候，往往又需要以整型（int）或长整型（long）为基本的传输类型，他们在大多数系统中，以 4 Bytes和 8 Bytes来表示。这样，为了传输一个整型（int）1，我们需要传输 “00000000 00000000 00000000 00000001” 32 个bits，除了一位是有价值的 1，其他全是基本无价值的 0（此处发出一个声音：浪！费！啊！）。

那怎么办呢？ZigZag 应用而生。那这个算法具体的思想是怎么样的呢？

对于正整数来讲，如果在传输的时候，我们把多余的 0 去掉（或者是尽可能去掉无意义的 0 ），传输有意义的 1 开始的数据，那我们是不是就可以做到数据的压缩了呢？那怎么样压缩无意义的 0 呢？

答案也很简单，比如：00000000 00000000 00000000 00000001。

这个数字，我们如果能只发送一位 1 或者一个字节 00000001，是不是就将压缩很多额外的数据呢？

当然，如果这个世界只有正整数，我们就会很方便的做到这一点。可惜，他居然还有负数！！！负数长什么样呢？例如：十进制 -1 补码为 “11111111 11111111 11111111 11111111”

前面全是 1，你说怎么弄？！

ZigZag 给出了一个很巧的方法：我们之前讲补码说过，补码的第一位是符号位，他阻碍了我们对于前导 0 的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位。

补：**1**1111111 11111111 11111111 11111111

→ 符号后移：11111111 11111111 11111111 111111**1**

但是即使这样，也是很难压缩的，因为数字绝对值越小，他所含的前导 1 越多。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数，如下：

十进制：-1

→ 补：**1**1111111 11111111 11111111 11111111

→ 符号后移：11111111 11111111 11111111 1111111**1**

→ ZigZag：00000000 00000000 00000000 0000000**1**

而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变，如下：

十进制：1

→ 补：**0**0000000 00000000 00000000 00000001

→ 符号后移：00000000 00000000 00000000 0000001**0**

→ ZigZag：00000000 00000000 00000000 0000001**0**

这样一弄，正数、0、负数都有同样的表示方法了。我们就可以对小整数进行压缩了，对吧~

这两种情况合并到一起，就可以写成如下的算法：

```go
func int32ToZigZag(n int32) int32 {
	return (n << 1) ^ (n >> 31)
}
```

`n << 1` 将整个值左移一位，不管正数、0、负数他们的最后一位都会变成了 0。讲解如下：

十进制：1

→ 补：**0**0000000 00000000 00000000 00000001

→ 左移一位：00000000 00000000 00000000 00000010

十进制：-1

→ 补：**1**1111111 11111111 11111111 11111111

→ 左移一位：11111111 11111111 11111111 11111110

`n >> 31` 将符号位放到最后一位。如果是非负数，则为全 0；如果是负数，就是全 1。讲解如下：

十进制：1

→ 补：**0**0000000 00000000 00000000 00000001

→ 右移 31 位：00000000 00000000 00000000 0000000**0**

十进制：-1

→ 补：**1**1111111 11111111 11111111 11111111

→ 右移 31 位：11111111 11111111 11111111 1111111**1**

最后这一步很巧妙，将两者进行按位异或操作。

十进制：1

→ `n << 1` ：00000000 00000000 00000000 00000010 ^ 

`n >> 31`： 00000000 00000000 00000000 0000000**0**

→ 00000000 00000000 00000000 0000001**0**

可以看到最终结果，数据位保持不变，而符号位也保持不变，只是符号位移动到了最后一位。

十进制：-1

→ `n << 1`：11111111 11111111 11111111 11111110 ^ 

`n >> 31`：11111111 11111111 11111111 1111111**1**

→ 00000000 00000000 00000000 0000000**1**

可以看到，数据位全部反转了，而符号位保持不变，且移动到了最后一位。就是这一行代码，就将这个相对复杂的操作做完了，真是写的巧妙。

ZigZag 还原代码如下：

```go
func toInt32(zz int32) int32 {
	return int32(uint32(zz)>>1) ^ -(zz & 1)
}
```

类似的，我们还原的代码就反过来写就可以了。不过这里要注意一点，就是右移的时候，需要用不带符号的移动，否则如果第一位数据位是 1 的话，就会补1。所以，代码里用了无符号的右移操作：`uint32(zz)>>1`。

好了，有了算法对数字进行转换以后，我们就得到了有前导 0 的另外一个整数了。不过他还是一个 4 字节的整数，我们接下来就要考虑怎么样将他们表示成尽可能少的字节数，并且还能还原。

比如，我们将 1 按照如上公式得到：00000000 00000000 00000000 00000010。

下来我们最好只需要发送 2 bits（10），或者发送 8 bits（00000010），把前面的 0 全部省掉。因为数据传输是以字节为单位，所以，我们最好保持 8 bits这样的单位。所以我们有 2 种做法：

- 我们可以额外增加一个字节，用来表示接下来有效的字节长度，比如：00000001 00000010，前 8 位表示接下来有 1 个字节需要传输，第二8位表示真正的数据。这种方式虽然能达到我们想要的效果，但是莫名的增加一个字节的额外浪费。有没有不浪费的办法呢？
- 字节自表示方法。ZigZag 引入了一个方法，就是用字节自己表示自己。具体怎么做呢？我们来看看代码。

```go
func compress(zz int32) []byte {
	var res []byte
	size := binary.Size(zz)
	for i := 0; i < size; i++ {
		if (zz & ^0x7F) != 0 {
			res = append(res, byte(0x80|(zz&0x7F)))
			zz = int32(uint32(zz) >> 7)
		} else {
			res = append(res, byte(zz&0x7F))
			break
		}
	}
	return res
}
```

大家先看看代码里那个 ^0x7F，他究竟是个什么数呢？

- ^0x7F：11111111 11111111 11111111 10000000

他就是从倒数第八位开始，高位全为 1 的数。他的作用就是去除最后七位后，判断还有没有信息。

我们把 ZigZag 值传递给这个函数，这个函数就将这个值从低位到高位切分成每 7 bits 一组，如果高位还有有效信息，则给这 7 bits 补上 1 个 bit 的 1（0x80）。如此反复 直到全是前导 0，便结束算法。

举个例来讲：

十进制：-1000

→ 补：**1**1111111 11111111 11111100 00011000

→ ZigZag：00000000 00000000 00000111 1100111**1**

我们先按照七位一组的方式将上面的数字划开，0000 0000000 0000000 0001111 1001111。

详细步骤如下：

1. 他跟 ^0x7F 做与操作的结果，高位还有信息，所以，我们把低 7 位取出来，并在倒数第八位上补一个 1（0x80）：11001111。
2. 将这个数右移七位，0000 0000000 0000000 0000000 0001111。
3. 再取出最后的七位，跟 ^0x7F 做与操作，发现高位已经没有信息了（全是0），那么我们就将最后 8 位完整的取出来：00001111，并且跳出循环，终止算法。
4. 最终，我们就得到了两个字节的数据 [11001111, 00001111]。

通过上面几步，我们就将一个 4 字节的 ZigZag 变换后的数字变成了一个 2 字节的数据。如果我们是网络传输的话，就直接发送这 2 个字节给对方进程。对方进程收到数据后，就可以进行数据的组装还原了。具体的还原操作如下：

```go
func decompress(zzByte []byte) int32 {
   var res int32
   for i, offset := 0, 0; i < len(zzByte); i, offset = i+1, offset+7 {
      b := zzByte[i]
      if (b & 0x80) == 0x80 {
         res |= int32(b&0x7F) << offset
      } else {
         res |= int32(b) << offset
         break
      }
   }
   return res
}
```

整个过程就和压缩的时候是逆向的：对于每一个字节，先看最高一位是否有 1（0x80）。如果有，就说明不是最后一个数据字节包，那取这个字节的最后七位进行拼装。否则，说明就是已经到了最后一个字节了，那直接拼装后，跳出循环，算法结束。最终得到 4 字节的整数。

## 结语

算法不是很复杂，遇到哪块不懂了，就好好观察想想，这也是对 Protobuf 原理理解的重要部分。如果有不懂的，就在下方给我留言！

完整代码：

[https://github.com/miaogaolin/gofirst/tree/main/zigzag](https://github.com/miaogaolin/gofirst/tree/main/zigzag)